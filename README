  Quickscope - a software oscilloscope
  Copyright (C) 2012-2014  Lance Arsenault
  GNU General Public License version 3+

--------------------------------------------------------------------

  Installing: See file INSTALL.  This is a standard GNU autotools
package.  In a shell run: './configure'; 'make'; and 'make install'.


  This file: contains general information about Quickscope and development
notes with arguments about it's design.


  Quickscope is computer programs and one or more libraries written in
C.  It has bindings for other languages, a shell interface, and GTK+
widgets.  It is an attempt at making a generic 2-D real-time
operator-in-the-loop display tool.  Something like a real oscilloscope but
with the flexibility of software not encumbered by limitations of
hardware, and then again not as fast a real scope.  We don't care if the
buttons and knobs don't necessarily look like a real scope, and to that
end we extend parameter controls beyond that of buttons and knobs given
the flexibility of software.

  When you consider how slow a computer pixel monitor and device input
rates you quickly conclude that it will be a very slow oscilloscope when
compared to even a very old 2MHz oscilloscope from the 1950's.  We decided
that if we could read and display most data from a 44kHz sample source,
like a sound card, without using a lot of computer resources, then we'd
consider pursuing this software oscilloscope.  In 2012 we wrote some code
and attempted to display all the sound data coming in at ~44kHz, and two
of the four computer's cores where pegged and it could barely do it, if
you did not challenge the computer with other tasks.  At this point you
are saying to yourself there are lots of software scopes that can do this.
We know this, but we are not interesting in making a simple sub-sampling
display, sweeping refresh software scope.  We are making generic fading
beam scope that has X-Y mode as well as triggered and free running sweep
modes.  Each frame displayed has any number of virtual beam traces, with
any number of inputs, be there triggers or not.  We wish to make a frame
work for building any kind of scope with any kind of computer input.  We
decided that if we could display a fading beam like a real scope, then it
would be interesting enough to pursue.  We will consider the non-fading
beam, sub-sampling wiping sweep that all other software scopes currently
use as some kind of degenerate mode of our fading beam scope.  Two years
later (2014) we got a new hand-me-down computer (Intel Quad Core i5-2500
3.30GHz CPU, 32GB DDR3) that was barely fast enough to pass our bench mark
and so Quickscope was born.  We suspect that the X server rendering code
improved too, which we have nothing to do with.

  We just use libX11's XDrawPoints() to draw.  Using such a simple
primitive means that we add a bit more code, but we found this necessary
in order to make this magical fading beam and have it fast enough to be
useful.

  OpenGL: We didn't bother trying to make this scope code faster by
writing openGL code and using direct rendering.  We didn't see much point
to that given that the current bottle neck is in the fading beam code and
by letting the X Server do the rendering it can be rendered in parallel
without having to write more code.  The X server seems to be using inter
process shared memory to transfer the pixel points that need to be drawn.
We have two drawing methods, buffered and unbuffered, which is just using
an X pixmap or not respectively.  Both buffered and unbuffered seem to
have some merit, depending on inputs and rates used.  It appears that the
X server is using openGL via Xrender, so why do we need to reinvent the
wheel, so to speak.  We are literally just drawing pixel points because we
found that was faster than drawing lines.

  We do not use Cario to draw as, GTK+ does.  We found it to be way to
slow.  We don't bother with anti-aliasing when drawing the beam, because
we found that that was way to slow.  We do a little anti-aliasing when
drawing the grid lines, which is not as a big resource usage compared to
anti-aliasing the beam lines.  The beam is only one pixel wide to minimize
the system resource usage.  Higher fidelity drawing things can be made
optional, but we will keep things as fast as possible by default.

  The resource usage, CPU and memory usage, depends heavily on the size of
the view port (window drawing areas).  Using 3 small view ports uses less
system resources than a single full screen view port.  

  The one interesting performance/fidelity consideration is the use
of drawing and hardware monitor refresh synchronizing.  By using the X
server to do the drawing we are also letting the X server determine when
it draws, and we are not synchronizing data sampling with the drawing.
Using gtk_widget_add_tick_callback() may do this.  Consider making a new
kind of controller to test this.  Seems to work a little better (~5% less
cpu usage) than the interval timer method (interval class).

  We use long double to measure time so that programs can run a long time
(say 10 years or so).   A program running 10 years, keeping time in
seconds will use log2(3600 * 24 * 365 * 10) = 28+ bits of the floating
point number leaving 53-29 = 22 bits (2^22 = 4194304) for a double (if we
used a double) which is just about enough, but we wish to push this limit
given that higher sample rates will be expected in the future.  Being able
to offset the time at regular intervals would get around this at the
expense of adding or fixing a glitch in the display at regular intervals.
So ya, time is a long double, even though we may not need it most of the
time.  On Linux amd64 systems gettimeofday() returns two 64 bit ints, one
for seconds and one for fractions of seconds.  Currently not all that
resolution is used.  It's clearly there so that it works well in the
future.  We are building Quickscope for the future too.



Class/Object structure:


  Managing an object means that the manager destroys the object
  when the manager is destroyed.


Class          Description
--------     ------------------------------------------------

app           global singlet object, parses command line
              options, keeps a default parameters settings
              that are used as objects are created and can
              have default settings changed just before
              objects that use them are created, has a
              timer object, app manages win and controller
              objects, destroying app will destroy every
              object in Quickscope



controller    base class for drawsync, interval and fd,
              manages sources, makes sense to have just one
              per program but can have more, calls sources'
              read callbacks, controller sets up a blocking
              call that is called regularly



drawsync      a controller that uses
              gtk_widget_add_tick_callback() so it should
              be calling the source read callbacks at each
              draw frame for an associated win object, the
              associated win manages this object, as does
              app


interval      a controller that manages a single callback
              interval using g_timeout_add_full(), which
              I imagine is using the system family of functions
              that are started with setitimer(),


fd            a controller that reads files, uses something
              like a glib wrapper of a blocking poll() call
              call using a g_source, used for efficient blocking
              read of a file,



source        we read data from a source, source callback
              controlled by controller using a controller,
              this allocates the buffer of data read that
              may be used to render in the beam trace,
              a (not pure virtual) base class for composer,
              sources cause traces to draw when they get new
              data, a source is an adjusterList, win adds
              adjusters from the sources in its traces to
              its adjusterList, app manages source objects,
              controllers that control sources manage sources,
              destroying a source will automatically destroy
              traces that use that source



group         a group of sources.  Has no public interfaces
              and is used internally only.



sweep         is a source that acts like a scope sweep with
              trigger, its a composer read callback that reads
              another source buffer to compose the sweep source,
              has lots of configuration parameters



trace         managed by a win, short for beam trace,
              has an X source and Y source,
              qsSource_addTraceDraw() connects to a source
              to get it's draw callback called in source's
              read callbacks after the source reads data


win           GTK+ window widget with drawing area,
              manages associated traces, manages associated
              drawsyncs, is an adjusterList with widgets you
              can interact with


adjuster      generic widget for adjusting a parameter


adjusterList  a list of adjusters, manages many adjuster
              objects, you can cycle through many adjuster(s)
              with an adjusters

widget        a widget that displays/inputs adjusters to
              and from the user


timer         simple gettimeofday() wrapper, there's one in
              app, turns time in seconds into a long double


assert        QS_ASSERT() and QS_VASSERT() macros
              that are automatically removed if
              configure --enable-debug is not set




On-the-fly Widget Changeable Parameter Types
--------------------------------------------------
type            example
------        ----------------------------------------
long double  -- sweep Delay, sweep Holdoff (times)
double       -- trace plot scale and shift
float        -- fadePeriod, fadePeriod
bool         -- points lines freeRun
selector     -- like radio selector, ex: sweep slope



Shell notes:


Class      On-the-fly Changeable Parameters
---------  ---------------------------------

win        fadeDrawPeriod fadePeriod drawPeriod
           backgroundColor gridColor

trace      points lines pointColor lineColor xScale xShift yScale yShift

interval   period

controller sources

sweep      period level slope holdOff
           sourceIn channelNumIn freeRun

program    userAddedParameter

composer   none in this base class
fd         none in this base class
source     none in this base class





  Why Quickscope is written in C:

We write Quickscope is C for many reasons.

1. We the original writers of Quickscope have lots of experience in
writing C code.

2. Making bindings to others languages is easiest if Quickscope is written
in C.

3. The compile time is much faster than if it where written in C++ or D.

4. It's less lines of code than if it's written in C++.  Debatable, yes.

5. X11 and GTK+ are written in C and have good C interfaces.

6. Less dependencies.

7. Easier access to input devices given the operating system is written
in C.



--------------------------- Legal Notice ----------------------------------

  Quickscope - a software oscilloscope

  Copyright (C) 2012-2014  Lance Arsenault

This file is part of Quickscope.

Quickscope is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.

Quickscope is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License, in the file COPYING, for more details.  

You should have received a copy of the GNU General Public License
along with Quickscope.  If not, see <http://www.gnu.org/licenses/>.
